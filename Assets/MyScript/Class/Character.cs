//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Character : MonoBehaviour
{
	private string characterName;
	private float maxHealth;
	private CharacterType type;
	private Character perfectMatch;
	private string asset;
	public Player PlayerOwner = null;
    public Game game;

    public CharacterAbility[] Ability = new CharacterAbility[5];

    public int DamageModifer = 0;

		#region MyRegion Property
	public Character PerfectMatch {
		get {
			return perfectMatch;
		}
		set {
			perfectMatch = value;
		}
	}

	public string Asset {
		get {
			return asset;
		}
		set {
			asset = value;
		}
	}

	public CharacterType Type {
		get {
			return type;
		}
		set {
			type = value;
		}
	}

    public float MaxHealth
    {
		get {
			return maxHealth;
		}
		set {
			maxHealth = value;
		}
	}

    public string CharacterName
    {
		get {
            return characterName;
		}
		set {
            characterName = value;
		}
	}
		#endregion

    public delegate IEnumerator AbilityDelegate(int number, Player source, Player victim);
    public AbilityDelegate JudgmentChange = null;
    public AbilityDelegate JudgementDone = null;
    public AbilityDelegate BeforeAttack = null;
    public AbilityDelegate BeforeAttacked = null;
    public AbilityDelegate EndAttack = null;
    public AbilityDelegate AttackDamageModifier = null;
    public AbilityDelegate BrinkOfDeath = null;
    public AbilityDelegate CausePhysicalDamage = null;
    public AbilityDelegate CauseMagicDamage = null;
    public AbilityDelegate TakePhysicalDamage = null;
    public AbilityDelegate TakeMagicDamage = null;
    public AbilityDelegate ChangeDamageToHealth = null;
    public AbilityDelegate BeforeTakeDamage = null;
    public AbilityDelegate UseCard = null;
    public AbilityDelegate BeginningOfTurn = null;
    public AbilityDelegate JudgementPhase = null;
    public AbilityDelegate DrawPhase = null;
    public AbilityDelegate ActionPhase = null;
    public AbilityDelegate DiscardPhase = null;
    public AbilityDelegate EndTurn = null;
    public AbilityDelegate AfterHealing = null;


	public enum CharacterType
	{
		Servant,
		Master,
		Human,
        Homunculus,
		Monster,
		Ruler,
		Boss,
	}

    void Start()
    {
        //this.PlayerOwner = gameObject.transform.parent.GetComponent<Player>();
        this.JudgementPhase += inJudgementPhase;
        this.EndTurn += inEndPhase;
    }

    public IEnumerator AbilityActive(CharacterAbility.AbilityForm type, int number, Player source, Player victim)
    {
        int busy = game.GetBusyTask();
        int free = game.GetFreeTask();
        foreach (CharacterAbility abi in Ability)
        {
            if (abi != null && abi.Form == type && abi.Status && abi.UsedTime < abi.UsedMax)
            {
                game.busy[free] = true;
                StartCoroutine(abi.Ability(number, source, victim));
                while(game.busy[free])yield return new WaitForSeconds(0.1f);
            }
        }
        game.busy[busy] = false;
    }

    public virtual IEnumerator inJudgementPhase(int number, Player source, Player victim)
    {
        int busy = game.GetBusyTask();
        int free = game.GetFreeTask();
        foreach (CharacterAbility ability in this.Ability)
        {
            if (ability != null)
            {
                ability.Used = false; 
                if(ability.limitType == CharacterAbility.LimitType.PerRound)ability.UsedTime = 0;
            }
        }
        game.busy[busy] = false;
        yield return new WaitForSeconds(0.1f);
    }

    public virtual IEnumerator inEndPhase(int number, Player source, Player victim)
    {
        int busy = game.GetBusyTask();
        int free = game.GetFreeTask();
        foreach (CharacterAbility ability in this.Ability)
        {
            if (ability != null)
            {
                ability.Used = false;
                if (ability.limitType == CharacterAbility.LimitType.PerTurn) ability.UsedTime = 0;
            }
        }
        game.busy[busy] = false;
        yield return new WaitForSeconds(0.1f);
    }

}

